\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage{geometry}
\usepackage{tabularx}
\usepackage[table,xcdraw,dvipsnames]{xcolor}
\usepackage{color}
\usepackage{subfig}
\usepackage{sidecap}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{multirow}
\setlength{\parindent}{0pt}
\usepackage{hyperref}
\usepackage{titlesec}
\titlelabel{\thetitle.\quad}
\usepackage{amsmath}
\usepackage{anyfontsize}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{multicol}
\usepackage{pgfplots}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{pgfplotstable}
\newgeometry{tmargin=1.8cm,bmargin=1.8cm,lmargin =1.8cm,rmargin=1.8cm}

\newgeometry{tmargin=1.8cm,bmargin=1.8cm,lmargin =1.8cm,rmargin=1.8cm}
\pagestyle{fancy}
\fancyhf{}
\rhead{\textit{Zuzanna Mejer} }
\lhead{\textit{Algorytmy sortowania} }
\cfoot{\thepage}


\begin{document}
\renewcommand{\figurename}{Rys.}
\renewcommand{\tablename}{Tab.}
    
\input{str_tytulowa.tex}
\tableofcontents
\newpage

\section{Wprowadzenie}
Zadanie miało na celu zapoznanie się z algorytmami sortowania oraz przeprowadzenie analizy efektywności wybranych i zaimplementowanych sortowań. Z wymienionych algorytmów wybrałam sortowania: przez scalanie, szybkie oraz introspektywne. 

\section{Opis badanych algorytmów i ich złożoność obliczeniowa}
\input{opis_badanych_algorytmow.tex}

\section{Implementacja algorytmów sortowania}
\input{implementacja_algorytmow.tex}

\section{Zadanie 1 - przeszukanie i przefiltrowanie danych}
\input{zadanie1.tex}

\section{Analiza złożoności algorytmów sortowań}
\input{analiza_zlozonosci.tex}

\section{Średnia wartość i mediana}
\input{srednia_mediana.tex}


\section{Podsumowanie i wnioski}
\begin{enumerate}
    \item Algorytm napisany do przeszukania i przefiltrowania danych okazał się niewydajny. Jego złożoność obliczeniowa wyniosła $O(n^2)$, co bardzo spowalniało cały program.
    \item Łączny czas wykonywania przeszukiwania i usuwania wybranych pól zajęła: 426561982926 ns, czyli około 7,10 min.
    \item Żadne z sortowań nie wykazało oczekiwanych złożoności obliczeniowych. Według tabeli \ref{tab: opis_zlozonosc}, typowa złożoność powinna wynieść $O(n log2 n)$. Sortowanie przez scalanie oraz sortowanie introspektywne wykazało złożoność liniową $O(n)$. Sortowanie szybkie dla najmniejszej liczby elementów, wykazało najgorszy przypadek - złożoność kwadratową $O(n^2)$, dla pozostałych zestawów danych - także złożoność liniową $O(n)$.
    \item W poniższej tabeli zestawiono czasy sortowań poszczególnych zestawów danych za pomocą zaimplementowanych algorytmów.
    \begin{table}[H]
        \centering
        \caption{Porównanie czasów sortowań}
        \label{tab:por_czas}
        \begin{tabular}{|c|cccc|}
        \hline
                               & \multicolumn{4}{c|}{liczba elementów}                                                                  \\ \hline
        czas sortowań {[}ms{]} & \multicolumn{1}{c|}{10 000} & \multicolumn{1}{c|}{100 000} & \multicolumn{1}{c|}{500 000} & maksymalna \\ \hline
        przez scalanie         & \multicolumn{1}{c|}{1,29}   & \multicolumn{1}{c|}{13,97}   & \multicolumn{1}{c|}{70,05}   & 138,48     \\ \hline
        szybkie                & \multicolumn{1}{c|}{1,49}   & \multicolumn{1}{c|}{11,71}   & \multicolumn{1}{c|}{57,67}   & 106,92     \\ \hline
        introspektywne         & \multicolumn{1}{c|}{0,29}   & \multicolumn{1}{c|}{36,54}   & \multicolumn{1}{c|}{148,90}  & 292,09     \\ \hline
        \end{tabular}
    \end{table}
    Zdecydowanie najlepszy czas, wyróżniający się dla małej liczby elementów (10 000) osiągnął algorytm sortowania introspektywnego, jednak dla większej liczby danych, zajął on najwięcej czasu. Sortowanie szybkie, zgodnie z oczekiwaniami, zajął najwięcej czasu podczas sortowania małej liczby elementów (10 000), natomiast wykazał się wydajnością dla większych zbiorów elementów. Sortowanie przez scalanie, w porównaniu do pozostałych 2 algorytmów, wypadło po środku.
    \item Wyznaczone średnie wartości i mediany dla każdego zestawu danych zostały przetestowane wszystkimi zaimplementowanymi algorytmami sortowań i dodatkowo potwierdzone funkcją \textit{std::sort}.

\end{enumerate}


\section{Bibliografia}
\begin{itemize}
    \item M. T. Goodrich, R. Tamassia, D. M. Mount; \textit{Data Structures and Algorithms in C++}
    \item https://en.cppreference.com/w/cpp/container/vector [dostęp: 6.05.2022]
    \item https://www.geeksforgeeks.org/introsort-or-introspective-sort/ [dostęp: 6.05.2022]
    \item https://pl.wikipedia.org/wiki/Sortowanie\_introspektywne [dostęp: 6.05.2022]
    \item http://www.algorytm.edu.pl/algorytmy-maturalne/quick-sort.html [dostęp: 6.05.2022]
    \item https://www.geeksforgeeks.org/merge-sort/ [dostęp: 6.05.2022]
\end{itemize}

\end{document}
